{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to Abulafia\n\n\nA C++ parsing framework",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-abulafia",
            "text": "A C++ parsing framework",
            "title": "Welcome to Abulafia"
        },
        {
            "location": "/guide/01_installation/",
            "text": "Installation\n\n\nRequirements\n\n\nIn order to use Abulafia, all you need is a (partially) compliant C++17 compiler, and matching standard library. As of right now, the following environments should be supported:\n\n\n\n\nGCC (7.2)\n\n\nclang (5.0.0)\n\n\nVisual Studio 2017 (update 3)\n\n\n\n\nInstallation\n\n\nSince Abulafia is a header-only library, all you need to do is get the source code from \ngithub\n, and make the contents of the \ninclude\n directory available to your compiler.\n\n\nThis can be as simple as copying the include/abulafia directory to your own source tree.\n\n\nConfiguration\n\n\nSince Abulafia is a template library, most configuration options are passed as template arguments, which allows multiple configurations of Abulafia to live side-by-side in the same application.\n\n\nHowever, some configuration options cannot be exposed this way. These can be found in the \nabulafia/config\n file, and can be manipulated by preprocessor macros (or outright editing of the config.h file).\n\n\nAs of right now, here are the available configuration options:\n\n\n\n\n\n\n\n\nOption name\n\n\ndefault value\n\n\ndescription\n\n\n\n\n\n\n\n\n\n\nABULAFIA_NAMESPACE\n\n\nabu\n\n\nThe namespace under which all abulafia is defined",
            "title": "Installation"
        },
        {
            "location": "/guide/01_installation/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/guide/01_installation/#requirements",
            "text": "In order to use Abulafia, all you need is a (partially) compliant C++17 compiler, and matching standard library. As of right now, the following environments should be supported:   GCC (7.2)  clang (5.0.0)  Visual Studio 2017 (update 3)",
            "title": "Requirements"
        },
        {
            "location": "/guide/01_installation/#installation_1",
            "text": "Since Abulafia is a header-only library, all you need to do is get the source code from  github , and make the contents of the  include  directory available to your compiler.  This can be as simple as copying the include/abulafia directory to your own source tree.",
            "title": "Installation"
        },
        {
            "location": "/guide/01_installation/#configuration",
            "text": "Since Abulafia is a template library, most configuration options are passed as template arguments, which allows multiple configurations of Abulafia to live side-by-side in the same application.  However, some configuration options cannot be exposed this way. These can be found in the  abulafia/config  file, and can be manipulated by preprocessor macros (or outright editing of the config.h file).  As of right now, here are the available configuration options:     Option name  default value  description      ABULAFIA_NAMESPACE  abu  The namespace under which all abulafia is defined",
            "title": "Configuration"
        },
        {
            "location": "/guide/02_parsers/",
            "text": "Parsers\n\n\nAt its core, Abulafia builds parsers by combining three components:\n\n\n\n\nA Pattern\n\n\nA Context\n\n\nA Destination (or \nnil\n)\n\n\n\n\nPatterns\n\n\nPatterns describe the expected structure of the data we want to parse. They can be as simple as expecting a single character, or describe grammars as complex as C++ itself. Most importantly, many parser classes provided by Abulafia take other parsers as arguments and compose them into more complicated behaviors.\n\n\nBecause composed patterns generate very complicated types through templates, they are generally stored in type-infered variables:\n\n\nauto my_pattern = int_ >> ',' >> *char('a', 'z');\n\n\n\nFurthermore, patterns are composed using \nvalue semantics\n. This means that writing reusable grammars is mostly a matter of creating a function that returns the proper pattern. This is the prefered way to create custom pattern types.\n1\n\n\n// Parses hexadecimal numbers, expecting them to be prefixed by the standard 0x\ntemplate<std::size_t MIN_DIGITS, std::size_t MAX_DIGITS>\nauto prefixed_hex() {\n  return (lit(\"0x\") | lit(\"0X\") >> Uint<16, MIN_DIGITS, MAX_DIGITS>();\n}\n\n\n\nContexts\n\n\nContexts are primarily used to specify how the data is being fed to the parsers. \n\n\nThe simplest of these is \nSingleForwardContext<>\n. It takes a pair of iterators, and assumes that they represent the entire totality of the data the parser will consume.\n\n\nDestinations\n\n\nQuite simply where the parser will store any and all extracted data. A parser will accept any type that are compatible with the assingments being performed in the parser.\n\n\nFor example:\n\n\n// A list of integers\nauto pattern = *int_;\n\n// These are all valid dst for our pattern\nstd::vector<int> dst_1;\nstd::vector<float> dst_2;\nstd::list<std::uint64_t> dst_3;\n\n\n\nThe Nil Destination\n\n\nAbulafia provides a special type: \nNil\n, with a matching constant: \nnil\n, that represents the concept of nothingness. Every pattern will always accept \nnil\n as a valid destination. Its use causes all parsers to stop generating any data\n2\n.\n\n\nPutting it all together\n\n\n#include <string>\n#include <vector>\n#include <cassert>\n#include \"abulafia/abulafia.h\"\n\nint main() {\n  std::string data = \"123456\";\n\n  // pattern\n  // A list of two-digits decimal-10 unsigned integer\n  auto pattern = *abu::Uint<10,2,2>; \n\n  // context\n  abu::SingleForwardContext<std::string::const_iterator> context(data.begin(), \n                                                                 data.end());\n\n  // destination\n  std::vector<unsigned short> destination;\n\n\n  // together, they make a parser\n  auto parser = abu::make_parser(pattern, context, destination);\n\n  auto status = parser.consume();\n\n  assert(status == abu::result::SUCCESS);\n  assert(destination.size() == 3);\n  assert(destination[0] == 12);\n  assert(destination[1] == 34);\n  assert(destination[2] == 56);\n\n  return 0;\n}\n\n\n\n\nMaking it cleaner\n\n\nThis is all fairly verbose. Since parsing a container all at once is such a common pattern, Abulafia provides a shorthand method:\n\n\n#include <string>\n#include <vector>\n#include <cassert>\n#include \"abulafia/abulafia.h\"\n\nint main() {\n  std::vector<unsigned short> destination;\n\n  auto status = abu::parse(*abu::Uint<10,2,2>,\n                           \"123456\",\n                           destination);\n\n  assert(status == abu::result::SUCCESS);\n\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nAbulafia itself uses this approach when it makes sense. Have a look at \nabulafia/patterns/leaf/char_literal.h\n for example.\u00a0\n\u21a9\n\n\n\n\n\n\nThis is a bit of a oversimplification. The parsers still generate data, but \nNil\n's assignments are all no-ops, so the compiler optimizes \naway the entire assignment routine of the parsers.\u00a0\n\u21a9",
            "title": "Parsers"
        },
        {
            "location": "/guide/02_parsers/#parsers",
            "text": "At its core, Abulafia builds parsers by combining three components:   A Pattern  A Context  A Destination (or  nil )",
            "title": "Parsers"
        },
        {
            "location": "/guide/02_parsers/#patterns",
            "text": "Patterns describe the expected structure of the data we want to parse. They can be as simple as expecting a single character, or describe grammars as complex as C++ itself. Most importantly, many parser classes provided by Abulafia take other parsers as arguments and compose them into more complicated behaviors.  Because composed patterns generate very complicated types through templates, they are generally stored in type-infered variables:  auto my_pattern = int_ >> ',' >> *char('a', 'z');  Furthermore, patterns are composed using  value semantics . This means that writing reusable grammars is mostly a matter of creating a function that returns the proper pattern. This is the prefered way to create custom pattern types. 1  // Parses hexadecimal numbers, expecting them to be prefixed by the standard 0x\ntemplate<std::size_t MIN_DIGITS, std::size_t MAX_DIGITS>\nauto prefixed_hex() {\n  return (lit(\"0x\") | lit(\"0X\") >> Uint<16, MIN_DIGITS, MAX_DIGITS>();\n}",
            "title": "Patterns"
        },
        {
            "location": "/guide/02_parsers/#contexts",
            "text": "Contexts are primarily used to specify how the data is being fed to the parsers.   The simplest of these is  SingleForwardContext<> . It takes a pair of iterators, and assumes that they represent the entire totality of the data the parser will consume.",
            "title": "Contexts"
        },
        {
            "location": "/guide/02_parsers/#destinations",
            "text": "Quite simply where the parser will store any and all extracted data. A parser will accept any type that are compatible with the assingments being performed in the parser.  For example:  // A list of integers\nauto pattern = *int_;\n\n// These are all valid dst for our pattern\nstd::vector<int> dst_1;\nstd::vector<float> dst_2;\nstd::list<std::uint64_t> dst_3;",
            "title": "Destinations"
        },
        {
            "location": "/guide/02_parsers/#the-nil-destination",
            "text": "Abulafia provides a special type:  Nil , with a matching constant:  nil , that represents the concept of nothingness. Every pattern will always accept  nil  as a valid destination. Its use causes all parsers to stop generating any data 2 .",
            "title": "The Nil Destination"
        },
        {
            "location": "/guide/02_parsers/#putting-it-all-together",
            "text": "#include <string>\n#include <vector>\n#include <cassert>\n#include \"abulafia/abulafia.h\"\n\nint main() {\n  std::string data = \"123456\";\n\n  // pattern\n  // A list of two-digits decimal-10 unsigned integer\n  auto pattern = *abu::Uint<10,2,2>; \n\n  // context\n  abu::SingleForwardContext<std::string::const_iterator> context(data.begin(), \n                                                                 data.end());\n\n  // destination\n  std::vector<unsigned short> destination;\n\n\n  // together, they make a parser\n  auto parser = abu::make_parser(pattern, context, destination);\n\n  auto status = parser.consume();\n\n  assert(status == abu::result::SUCCESS);\n  assert(destination.size() == 3);\n  assert(destination[0] == 12);\n  assert(destination[1] == 34);\n  assert(destination[2] == 56);\n\n  return 0;\n}",
            "title": "Putting it all together"
        },
        {
            "location": "/guide/02_parsers/#making-it-cleaner",
            "text": "This is all fairly verbose. Since parsing a container all at once is such a common pattern, Abulafia provides a shorthand method:  #include <string>\n#include <vector>\n#include <cassert>\n#include \"abulafia/abulafia.h\"\n\nint main() {\n  std::vector<unsigned short> destination;\n\n  auto status = abu::parse(*abu::Uint<10,2,2>,\n                           \"123456\",\n                           destination);\n\n  assert(status == abu::result::SUCCESS);\n\n  return 0;\n}      Abulafia itself uses this approach when it makes sense. Have a look at  abulafia/patterns/leaf/char_literal.h  for example.\u00a0 \u21a9    This is a bit of a oversimplification. The parsers still generate data, but  Nil 's assignments are all no-ops, so the compiler optimizes \naway the entire assignment routine of the parsers.\u00a0 \u21a9",
            "title": "Making it cleaner"
        },
        {
            "location": "/guide/03_skippers/",
            "text": "Skippers\n\n\nSkipping whitespace is a common task\n\n\nA very common pattern is allowing arbitrary white space between elements of a given grammar.\n\n\nThis could be acheived like this:\n\n\n// a list of 0 to N characters in the whitespace char set\n// that emits nothing to the destination.\n// ows stands for Optional White Space\nauto ows = ignore(\n  *char_(\" \\r\\n\\t\")\n  );\n\n// a list of integers, that ignores any whitespace before it.\nauto pattern = *(ows >> int_);\n\n\n\nHowever, this can quickly become tedious, and makes parsers hard to read:\n\n\nauto alnum = char_set::range('a', 'z') + \n             char_set::range('A', 'Z') + \n             char_set::range('0', '9');\n\nauto ows = ignore(*char_(\" \\r\\n\\t\"));\n\nauto name = *char_(alnum);\n\nauto player = ows >> name >> // first name\n              ows >> name >> // last name\n              ows >> uint_;  // score\n\nparse(player, \"John Doe    123\");\n\n\n\nIntroducing Skippers\n\n\nThankfully Abulafia provides us with \nskippers\n, which automate the task of applying whitespace before \neach sub-parser.\n\n\nauto alnum = char_set::range('a', 'z') + \n             char_set::range('A', 'Z') + \n             char_set::range('0', '9');\n\nauto name = lexeme(*char_(alnum));\n\nauto whitespace = char_(\" \\r\\n\\t\");\nauto player = name >> name >> uint_;  // first name, last name, score\n\nparse(apply_skipper(player, whitespace), \"John Doe    123\");\n\n\n\napply_skipper()\n will tell abulafia that every parser underneath it will be prefixed with an ignored repetition of the skipper pattern (\nwhitespace\n in our example).\n\n\nOn the other side of the coin, \nlexeme()\n tells abulafia that the parser is to be considered as a logic unit, effectively disabling the skipper. Without it, the first name would be parsed as \"JohnDoe123\", since the white space between the letters would get skipped.",
            "title": "Skippers"
        },
        {
            "location": "/guide/03_skippers/#skippers",
            "text": "",
            "title": "Skippers"
        },
        {
            "location": "/guide/03_skippers/#skipping-whitespace-is-a-common-task",
            "text": "A very common pattern is allowing arbitrary white space between elements of a given grammar.  This could be acheived like this:  // a list of 0 to N characters in the whitespace char set\n// that emits nothing to the destination.\n// ows stands for Optional White Space\nauto ows = ignore(\n  *char_(\" \\r\\n\\t\")\n  );\n\n// a list of integers, that ignores any whitespace before it.\nauto pattern = *(ows >> int_);  However, this can quickly become tedious, and makes parsers hard to read:  auto alnum = char_set::range('a', 'z') + \n             char_set::range('A', 'Z') + \n             char_set::range('0', '9');\n\nauto ows = ignore(*char_(\" \\r\\n\\t\"));\n\nauto name = *char_(alnum);\n\nauto player = ows >> name >> // first name\n              ows >> name >> // last name\n              ows >> uint_;  // score\n\nparse(player, \"John Doe    123\");",
            "title": "Skipping whitespace is a common task"
        },
        {
            "location": "/guide/03_skippers/#introducing-skippers",
            "text": "Thankfully Abulafia provides us with  skippers , which automate the task of applying whitespace before \neach sub-parser.  auto alnum = char_set::range('a', 'z') + \n             char_set::range('A', 'Z') + \n             char_set::range('0', '9');\n\nauto name = lexeme(*char_(alnum));\n\nauto whitespace = char_(\" \\r\\n\\t\");\nauto player = name >> name >> uint_;  // first name, last name, score\n\nparse(apply_skipper(player, whitespace), \"John Doe    123\");  apply_skipper()  will tell abulafia that every parser underneath it will be prefixed with an ignored repetition of the skipper pattern ( whitespace  in our example).  On the other side of the coin,  lexeme()  tells abulafia that the parser is to be considered as a logic unit, effectively disabling the skipper. Without it, the first name would be parsed as \"JohnDoe123\", since the white space between the letters would get skipped.",
            "title": "Introducing Skippers"
        },
        {
            "location": "/patterns/reference/",
            "text": "",
            "title": "Quick Reference"
        },
        {
            "location": "/patterns/leaf/numeric/int/",
            "text": "",
            "title": "Integer"
        },
        {
            "location": "/patterns/leaf/character/",
            "text": "",
            "title": "Character"
        },
        {
            "location": "/patterns/leaf/eoi/",
            "text": "",
            "title": "End-of-input"
        },
        {
            "location": "/patterns/leaf/fail/",
            "text": "",
            "title": "Fail"
        },
        {
            "location": "/patterns/leaf/literal/",
            "text": "",
            "title": "Literal"
        },
        {
            "location": "/patterns/leaf/pass/",
            "text": "",
            "title": "Pass"
        },
        {
            "location": "/patterns/leaf/Symbol/",
            "text": "",
            "title": "Symbol"
        },
        {
            "location": "/patterns/unary/not/",
            "text": "",
            "title": "not"
        },
        {
            "location": "/patterns/unary/repeat/",
            "text": "",
            "title": "repeat"
        },
        {
            "location": "/patterns/binary/except/",
            "text": "",
            "title": "except"
        },
        {
            "location": "/patterns/binary/list/",
            "text": "",
            "title": "list"
        },
        {
            "location": "/patterns/nary/alternative/",
            "text": "",
            "title": "Alternative"
        },
        {
            "location": "/patterns/nary/sequence/",
            "text": "",
            "title": "Sequence"
        },
        {
            "location": "/patterns/recur/",
            "text": "",
            "title": "Recursive"
        },
        {
            "location": "/patterns/action/",
            "text": "",
            "title": "Semantic Action"
        }
    ]
}