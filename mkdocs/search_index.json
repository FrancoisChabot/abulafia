{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to Abulafia\n\n\nA C++ parsing framework",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-abulafia",
            "text": "A C++ parsing framework",
            "title": "Welcome to Abulafia"
        },
        {
            "location": "/guide/00_introduction/",
            "text": "Introduction\n\n\nWelcome to the Abulafia user guide.\n\n\nThis document is meant to get you up to speed so that you can use Abulafia within your project.\n\n\nWhat this guide is not\n\n\nThis guide does not contain an in-depth description of every feature and parser available in Abulafia. \nIt is meant to provide enough information and background to get started, but is by no means a comprehensive guide.\nThe \nreference\n covers everything in much greater details.",
            "title": "Introduction"
        },
        {
            "location": "/guide/00_introduction/#introduction",
            "text": "Welcome to the Abulafia user guide.  This document is meant to get you up to speed so that you can use Abulafia within your project.",
            "title": "Introduction"
        },
        {
            "location": "/guide/00_introduction/#what-this-guide-is-not",
            "text": "This guide does not contain an in-depth description of every feature and parser available in Abulafia. \nIt is meant to provide enough information and background to get started, but is by no means a comprehensive guide.\nThe  reference  covers everything in much greater details.",
            "title": "What this guide is not"
        },
        {
            "location": "/guide/01_installation/",
            "text": "Installation\n\n\nRequirements\n\n\nIn order to use Abulafia, all you need is a (partially) compliant C++17 compiler, and matching standard library. As of right now, the following environments should be supported:\n\n\n\n\nGCC (7.2)\n\n\nclang (5.0.0)\n\n\nVisual Studio 2017 (update 3)\n\n\n\n\nInstallation\n\n\nSince Abulafia is a header-only library, all you need to do is get the source code from \ngithub\n, and make the contents of the \ninclude\n directory available to your compiler.\n\n\nThis can be as simple as copying the include/abulafia directory to your own source tree.\n\n\nWe also maintain a single-header version of the library. You can build it yourself, using the \ngenerate_all_include\n build target, or get it from the \ngithub branch\n, where it is kept in sync with the master branch.\n\n\nConfiguration\n\n\nSince Abulafia is a template library, most configuration options are passed as template arguments, which allows multiple configurations of Abulafia to live side-by-side in the same application.\n\n\nHowever, some configuration options cannot be exposed this way. These can be found in the \nabulafia/config.h\n file, and can be manipulated by preprocessor macros (or outright editing of the config.h file).\n\n\nAs of right now, here are the available configuration options:\n\n\n\n\n\n\n\n\nOption name\n\n\ndefault value\n\n\ndescription\n\n\n\n\n\n\n\n\n\n\nABULAFIA_NAMESPACE\n\n\nabu\n\n\nThe namespace under which all abulafia is defined",
            "title": "Installation"
        },
        {
            "location": "/guide/01_installation/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/guide/01_installation/#requirements",
            "text": "In order to use Abulafia, all you need is a (partially) compliant C++17 compiler, and matching standard library. As of right now, the following environments should be supported:   GCC (7.2)  clang (5.0.0)  Visual Studio 2017 (update 3)",
            "title": "Requirements"
        },
        {
            "location": "/guide/01_installation/#installation_1",
            "text": "Since Abulafia is a header-only library, all you need to do is get the source code from  github , and make the contents of the  include  directory available to your compiler.  This can be as simple as copying the include/abulafia directory to your own source tree.  We also maintain a single-header version of the library. You can build it yourself, using the  generate_all_include  build target, or get it from the  github branch , where it is kept in sync with the master branch.",
            "title": "Installation"
        },
        {
            "location": "/guide/01_installation/#configuration",
            "text": "Since Abulafia is a template library, most configuration options are passed as template arguments, which allows multiple configurations of Abulafia to live side-by-side in the same application.  However, some configuration options cannot be exposed this way. These can be found in the  abulafia/config.h  file, and can be manipulated by preprocessor macros (or outright editing of the config.h file).  As of right now, here are the available configuration options:     Option name  default value  description      ABULAFIA_NAMESPACE  abu  The namespace under which all abulafia is defined",
            "title": "Configuration"
        },
        {
            "location": "/guide/02_parsers/",
            "text": "Parsers\n\n\nAt its core, Abulafia builds parsers by combining three components:\n\n\n\n\nA Pattern\n\n\nA Context\n\n\nA Destination (or \nnil\n)\n\n\n\n\nPatterns\n\n\nPatterns describe the expected structure of the data we want to parse. They can be as simple as expecting a single character, or describe grammars as complex as C++ itself. Most importantly, many parser classes provided by Abulafia take other parsers as arguments and compose them into more complicated behaviors.\n\n\nBecause composed patterns generate very complicated types through templates, they are generally stored in type-infered variables:\n\n\nauto\n \nmy_pattern\n \n=\n \nint_\n \n>>\n \n','\n \n>>\n \n*\nchar\n(\n'a'\n,\n \n'z'\n);\n\n\n\n\n\n\nFurthermore, patterns are composed using \nvalue semantics\n. This means that writing reusable grammars is mostly a matter of creating a function that returns the proper pattern. This is the prefered way to create custom pattern types.\n1\n\n\n// Parses hexadecimal numbers, expecting them to be prefixed by the standard 0x\n\n\ntemplate\n<\nstd\n::\nsize_t\n \nMIN_DIGITS\n,\n \nstd\n::\nsize_t\n \nMAX_DIGITS\n>\n\n\nauto\n \nprefixed_hex\n()\n \n{\n\n  \nreturn\n \n(\nlit\n(\n\"0x\"\n)\n \n|\n \nlit\n(\n\"0X\"\n)\n \n>>\n \nUint\n<\n16\n,\n \nMIN_DIGITS\n,\n \nMAX_DIGITS\n>\n();\n\n\n}\n\n\n\n\n\n\nContexts\n\n\nContexts are primarily used to specify how the data is being fed to the parsers. \n\n\nThe simplest of these is \nSingleForwardContext<>\n. It takes a pair of iterators, and assumes that they represent the entire totality of the data the parser will consume.\n\n\nDestinations\n\n\nQuite simply where the parser will store any and all extracted data. A parser will accept any type that are compatible with the assingments being performed in the parser.\n\n\nFor example:\n\n\n// A list of integers\n\n\nauto\n \npattern\n \n=\n \n*\nint_\n;\n\n\n\n// These are all valid dst for our pattern\n\n\nstd\n::\nvector\n<\nint\n>\n \ndst_1\n;\n\n\nstd\n::\nvector\n<\nfloat\n>\n \ndst_2\n;\n\n\nstd\n::\nlist\n<\nstd\n::\nuint64_t\n>\n \ndst_3\n;\n\n\n\n\n\n\nThe Nil Destination\n\n\nAbulafia provides a special type: \nNil\n, with a matching constant: \nnil\n, that represents the concept of nothingness. Every pattern will always accept \nnil\n as a valid destination. Its use causes all parsers to stop generating any data\n2\n.\n\n\nPutting it all together\n\n\n#include\n \n<string>\n\n\n#include\n \n<vector>\n\n\n#include\n \n<cassert>\n\n\n#include\n \n\"abulafia/abulafia.h\"\n\n\n\nint\n \nmain\n()\n \n{\n\n  \nstd\n::\nstring\n \ndata\n \n=\n \n\"123456\"\n;\n\n\n  \n// pattern\n\n  \n// A list of two-digits decimal-10 unsigned integers\n\n  \nauto\n \npattern\n \n=\n \n*\nabu\n::\nUint\n<\n10\n,\n2\n,\n2\n>\n;\n \n\n  \n// context\n\n  \n// Consume a pair of `std::string` iterators all at once\n\n  \nabu\n::\nSingleForwardContext\n<\nstd\n::\nstring\n::\nconst_iterator\n>\n \ncontext\n(\ndata\n.\nbegin\n(),\n \n                                                                 \ndata\n.\nend\n());\n\n\n  \n// destination\n\n  \nstd\n::\nvector\n<\nunsigned\n \nshort\n>\n \ndestination\n;\n\n\n\n  \n// Together, they make a parser\n\n  \nauto\n \nparser\n \n=\n \nabu\n::\nmake_parser\n(\npattern\n,\n \ncontext\n,\n \ndestination\n);\n\n\n  \nauto\n \nstatus\n \n=\n \nparser\n.\nconsume\n();\n\n\n  \nassert\n(\nstatus\n \n==\n \nabu\n::\nResult\n::\nSUCCESS\n);\n\n  \nassert\n(\ndestination\n.\nsize\n()\n \n==\n \n3\n);\n\n  \nassert\n(\ndestination\n[\n0\n]\n \n==\n \n12\n);\n\n  \nassert\n(\ndestination\n[\n1\n]\n \n==\n \n34\n);\n\n  \nassert\n(\ndestination\n[\n2\n]\n \n==\n \n56\n);\n\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nMaking it cleaner\n\n\nThis is all fairly verbose. Since parsing a container all at once is such a common pattern, Abulafia provides a shorthand method.\nSimple patterns can also be inlined directly into the parse call.\n\n\n#include\n \n<string>\n\n\n#include\n \n<vector>\n\n\n#include\n \n<cassert>\n\n\n\n#include\n \n\"abulafia/abulafia.h\"\n\n\n\nint\n \nmain\n()\n \n{\n\n  \nstd\n::\nvector\n<\nunsigned\n \nshort\n>\n \ndestination\n;\n\n\n  \nauto\n \nstatus\n \n=\n \nabu\n::\nparse\n(\n*\nabu\n::\nUint\n<\n10\n,\n \n2\n,\n \n2\n>\n,\n\n                           \n\"123456\"\n,\n\n                           \ndestination\n);\n\n\n  \nassert\n(\nstatus\n \n==\n \nabu\n::\nresult\n::\nSUCCESS\n);\n\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbulafia itself uses this approach when it makes sense. Have a look at \nabulafia/patterns/leaf/char_literal.h\n for example.\u00a0\n\u21a9\n\n\n\n\n\n\nThis is a bit of a oversimplification. The parsers still generate data, but \nNil\n's assignments are all no-ops, so the compiler optimizes \naway the entire assignment routine of the parsers.\u00a0\n\u21a9",
            "title": "Parsers"
        },
        {
            "location": "/guide/02_parsers/#parsers",
            "text": "At its core, Abulafia builds parsers by combining three components:   A Pattern  A Context  A Destination (or  nil )",
            "title": "Parsers"
        },
        {
            "location": "/guide/02_parsers/#patterns",
            "text": "Patterns describe the expected structure of the data we want to parse. They can be as simple as expecting a single character, or describe grammars as complex as C++ itself. Most importantly, many parser classes provided by Abulafia take other parsers as arguments and compose them into more complicated behaviors.  Because composed patterns generate very complicated types through templates, they are generally stored in type-infered variables:  auto   my_pattern   =   int_   >>   ','   >>   * char ( 'a' ,   'z' );   Furthermore, patterns are composed using  value semantics . This means that writing reusable grammars is mostly a matter of creating a function that returns the proper pattern. This is the prefered way to create custom pattern types. 1  // Parses hexadecimal numbers, expecting them to be prefixed by the standard 0x  template < std :: size_t   MIN_DIGITS ,   std :: size_t   MAX_DIGITS >  auto   prefixed_hex ()   { \n   return   ( lit ( \"0x\" )   |   lit ( \"0X\" )   >>   Uint < 16 ,   MIN_DIGITS ,   MAX_DIGITS > ();  }",
            "title": "Patterns"
        },
        {
            "location": "/guide/02_parsers/#contexts",
            "text": "Contexts are primarily used to specify how the data is being fed to the parsers.   The simplest of these is  SingleForwardContext<> . It takes a pair of iterators, and assumes that they represent the entire totality of the data the parser will consume.",
            "title": "Contexts"
        },
        {
            "location": "/guide/02_parsers/#destinations",
            "text": "Quite simply where the parser will store any and all extracted data. A parser will accept any type that are compatible with the assingments being performed in the parser.  For example:  // A list of integers  auto   pattern   =   * int_ ;  // These are all valid dst for our pattern  std :: vector < int >   dst_1 ;  std :: vector < float >   dst_2 ;  std :: list < std :: uint64_t >   dst_3 ;",
            "title": "Destinations"
        },
        {
            "location": "/guide/02_parsers/#the-nil-destination",
            "text": "Abulafia provides a special type:  Nil , with a matching constant:  nil , that represents the concept of nothingness. Every pattern will always accept  nil  as a valid destination. Its use causes all parsers to stop generating any data 2 .",
            "title": "The Nil Destination"
        },
        {
            "location": "/guide/02_parsers/#putting-it-all-together",
            "text": "#include   <string>  #include   <vector>  #include   <cassert>  #include   \"abulafia/abulafia.h\"  int   main ()   { \n   std :: string   data   =   \"123456\" ; \n\n   // pattern \n   // A list of two-digits decimal-10 unsigned integers \n   auto   pattern   =   * abu :: Uint < 10 , 2 , 2 > ;  \n\n   // context \n   // Consume a pair of `std::string` iterators all at once \n   abu :: SingleForwardContext < std :: string :: const_iterator >   context ( data . begin (),  \n                                                                  data . end ()); \n\n   // destination \n   std :: vector < unsigned   short >   destination ; \n\n\n   // Together, they make a parser \n   auto   parser   =   abu :: make_parser ( pattern ,   context ,   destination ); \n\n   auto   status   =   parser . consume (); \n\n   assert ( status   ==   abu :: Result :: SUCCESS ); \n   assert ( destination . size ()   ==   3 ); \n   assert ( destination [ 0 ]   ==   12 ); \n   assert ( destination [ 1 ]   ==   34 ); \n   assert ( destination [ 2 ]   ==   56 ); \n\n   return   0 ;  }",
            "title": "Putting it all together"
        },
        {
            "location": "/guide/02_parsers/#making-it-cleaner",
            "text": "This is all fairly verbose. Since parsing a container all at once is such a common pattern, Abulafia provides a shorthand method.\nSimple patterns can also be inlined directly into the parse call.  #include   <string>  #include   <vector>  #include   <cassert>  #include   \"abulafia/abulafia.h\"  int   main ()   { \n   std :: vector < unsigned   short >   destination ; \n\n   auto   status   =   abu :: parse ( * abu :: Uint < 10 ,   2 ,   2 > , \n                            \"123456\" , \n                            destination ); \n\n   assert ( status   ==   abu :: result :: SUCCESS ); \n\n   return   0 ;  }       Abulafia itself uses this approach when it makes sense. Have a look at  abulafia/patterns/leaf/char_literal.h  for example.\u00a0 \u21a9    This is a bit of a oversimplification. The parsers still generate data, but  Nil 's assignments are all no-ops, so the compiler optimizes \naway the entire assignment routine of the parsers.\u00a0 \u21a9",
            "title": "Making it cleaner"
        },
        {
            "location": "/guide/03_skippers/",
            "text": "Skippers\n\n\nSkipping whitespace is a common task\n\n\nA very common pattern is allowing arbitrary white space between elements of a given grammar.\n\n\nThis could be acheived like this:\n\n\n// a list of 0 to N characters in the whitespace char set\n\n\n// that emits nothing to the destination.\n\n\n// ows stands for Optional White Space\n\n\nauto\n \nows\n \n=\n \nignore\n(\n\n  \n*\nchar_\n(\n\" \n\\r\\n\\t\n\"\n)\n\n  \n);\n\n\n\n// a list of integers, that ignores any whitespace before it.\n\n\nauto\n \npattern\n \n=\n \n*\n(\nows\n \n>>\n \nint_\n);\n\n\n\n\n\n\nHowever, this can quickly become tedious, and makes parsers hard to read:\n\n\nauto\n \nalnum\n \n=\n \nchar_set\n::\nrange\n(\n'a'\n,\n \n'z'\n)\n \n+\n \n             \nchar_set\n::\nrange\n(\n'A'\n,\n \n'Z'\n)\n \n+\n \n             \nchar_set\n::\nrange\n(\n'0'\n,\n \n'9'\n);\n\n\n\nauto\n \nows\n \n=\n \nignore\n(\n*\nchar_\n(\n\" \n\\r\\n\\t\n\"\n));\n\n\n\nauto\n \nname\n \n=\n \n*\nchar_\n(\nalnum\n);\n\n\n\nauto\n \nplayer\n \n=\n \nows\n \n>>\n \nname\n \n>>\n \n// first name\n\n              \nows\n \n>>\n \nname\n \n>>\n \n// last name\n\n              \nows\n \n>>\n \nuint_\n;\n  \n// score\n\n\n\nparse\n(\nplayer\n,\n \n\"John Doe    123\"\n);\n\n\n\n\n\n\nIntroducing Skippers\n\n\nThankfully Abulafia provides us with \nskippers\n, which automate the task of applying whitespace before \neach sub-parser.\n\n\nauto\n \nalnum\n \n=\n \nchar_set\n::\nrange\n(\n'a'\n,\n \n'z'\n)\n \n+\n \n             \nchar_set\n::\nrange\n(\n'A'\n,\n \n'Z'\n)\n \n+\n \n             \nchar_set\n::\nrange\n(\n'0'\n,\n \n'9'\n);\n\n\n\nauto\n \nname\n \n=\n \nlexeme\n(\n*\nchar_\n(\nalnum\n));\n\n\n\nauto\n \nwhitespace\n \n=\n \nchar_\n(\n\" \n\\r\\n\\t\n\"\n);\n\n\nauto\n \nplayer\n \n=\n \nname\n \n>>\n \nname\n \n>>\n \nuint_\n;\n  \n// first name, last name, score\n\n\n\nparse\n(\napply_skipper\n(\nplayer\n,\n \nwhitespace\n),\n \n\"John Doe    123\"\n);\n\n\n\n\n\n\napply_skipper()\n will tell abulafia that every parser underneath it will be prefixed with an ignored repetition of the skipper pattern (\nwhitespace\n in our example).\n\n\nOn the other side of the coin, \nlexeme()\n tells abulafia that the parser is to be considered as a logical unit, effectively disabling the skipper. Without it, the first name would be parsed as \"JohnDoe123\", since the white space between the letters would get skipped.",
            "title": "Skippers"
        },
        {
            "location": "/guide/03_skippers/#skippers",
            "text": "",
            "title": "Skippers"
        },
        {
            "location": "/guide/03_skippers/#skipping-whitespace-is-a-common-task",
            "text": "A very common pattern is allowing arbitrary white space between elements of a given grammar.  This could be acheived like this:  // a list of 0 to N characters in the whitespace char set  // that emits nothing to the destination.  // ows stands for Optional White Space  auto   ows   =   ignore ( \n   * char_ ( \"  \\r\\n\\t \" ) \n   );  // a list of integers, that ignores any whitespace before it.  auto   pattern   =   * ( ows   >>   int_ );   However, this can quickly become tedious, and makes parsers hard to read:  auto   alnum   =   char_set :: range ( 'a' ,   'z' )   +  \n              char_set :: range ( 'A' ,   'Z' )   +  \n              char_set :: range ( '0' ,   '9' );  auto   ows   =   ignore ( * char_ ( \"  \\r\\n\\t \" ));  auto   name   =   * char_ ( alnum );  auto   player   =   ows   >>   name   >>   // first name \n               ows   >>   name   >>   // last name \n               ows   >>   uint_ ;    // score  parse ( player ,   \"John Doe    123\" );",
            "title": "Skipping whitespace is a common task"
        },
        {
            "location": "/guide/03_skippers/#introducing-skippers",
            "text": "Thankfully Abulafia provides us with  skippers , which automate the task of applying whitespace before \neach sub-parser.  auto   alnum   =   char_set :: range ( 'a' ,   'z' )   +  \n              char_set :: range ( 'A' ,   'Z' )   +  \n              char_set :: range ( '0' ,   '9' );  auto   name   =   lexeme ( * char_ ( alnum ));  auto   whitespace   =   char_ ( \"  \\r\\n\\t \" );  auto   player   =   name   >>   name   >>   uint_ ;    // first name, last name, score  parse ( apply_skipper ( player ,   whitespace ),   \"John Doe    123\" );   apply_skipper()  will tell abulafia that every parser underneath it will be prefixed with an ignored repetition of the skipper pattern ( whitespace  in our example).  On the other side of the coin,  lexeme()  tells abulafia that the parser is to be considered as a logical unit, effectively disabling the skipper. Without it, the first name would be parsed as \"JohnDoe123\", since the white space between the letters would get skipped.",
            "title": "Introducing Skippers"
        },
        {
            "location": "/guide/04_resumable_parsers/",
            "text": "Resumable Parsers\n\n\nAbulafia parsers have the option\n1\n of running as coroutines. That is, they are capable of pausing their execution when starved for data, and resume once data is available, all without the need for multithreading and synchronisation.\n\n\nContainerSequenceContext\n\n\nThe \nContainer Sequence Context\n is the prefered way of dealing with data chunks. It's fast, flexible, and does as little memory management work as possible at the cost of possibly holding on to chunks of memory longer than absolutely necessary.\n2\n\n\n#include\n \n<vector>\n\n\n\n#include\n \n\"abulafia/abulafia.h\"\n\n\n\nint\n \nmain\n()\n \n{\n\n  \nauto\n \npattern\n \n=\n \n*\nabu\n::\nUint\n<\n10\n,\n2\n,\n2\n>\n;\n \n  \nstd\n::\nvector\n<\nunsigned\n \nshort\n>\n \ndestination\n;\n\n\n  \n// Our resumable context will be provided with vectors of char\n\n  \nabu\n::\nContainerSequenceContext\n<\nstd\n::\nstring\n>\n \ncontext\n;\n\n\n  \nauto\n \nparser\n \n=\n \nabu\n::\nmake_parser\n(\npattern\n,\n \ncontext\n,\n \ndestination\n);\n\n\n  \nconstexpr\n \nint\n \nCHUNK_SIZE\n \n=\n \n256\n;\n\n  \nstd\n::\nifstream\n \nfile\n(\n\"data.txt\"\n);\n\n\n  \nabu\n::\nResult\n \nfinal_result\n \n=\n \nabu\n::\nResult\n::\nPARTIAL\n;\n\n  \nwhile\n(\nfinal_result\n \n==\n \nabu\n::\nResult\n::\nPARTIAL\n)\n \n{\n\n    \nauto\n \nbuffer\n \n=\n \nstd\n::\nmake_unique\n<\nstd\n::\nvector\n<\nchar\n>>\n(\nCHUNK_SIZE\n);\n     \n\n    \nbool\n \nread_status\n \n=\n \nfile\n.\nread\n(\nbuffer\n->\ndata\n(),\n \nCHUNK_SIZE\n);\n\n\n    \nbuffer\n->\nresize\n(\nfile\n.\ngcount\n());\n\n\n    \n// The context takes ownership of the data, and will let go of it as soon\n\n    \n// as it can prove it won't need it again. No memory copies are involved.\n\n    \ncontext\n.\naddBuffer\n(\nstd\n::\nmove\n(\ndata\n),\n \nread_status\n \n?\n \nabu\n::\nIsFinal\n::\nNOT_FINAL\n \n:\n \nabu\n::\nIsFinal\n::\nFINAL\n);\n\n\n    \nfinal_result\n \n=\n \nparser\n.\nconsume\n();\n\n  \n}\n\n\n  \n// Deal with the status/destination here...\n\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nThe most important takeaway here is that \nconsume()\n can return 3 possible values:\n\n\n\n\n\n\n\n\nValue\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nabu::Result::SUCCESS\n\n\nThe parser has successfully completed\n\n\n\n\n\n\nabu::Result::FAILURE\n\n\nThe parser has failed\n\n\n\n\n\n\nabu::Result::PARTIAL\n\n\nThe parser needs more data\n\n\n\n\n\n\n\n\nOnce you have provided a buffer with the \nabu::IsFinal::FINAL\n flag, the next consume operation will either succeed or fail.\n\n\n\n\n\n\n\n\n\n\nIn classic C++ fashion, you only pay for the overhead of this feature if you actually use it. Using abulafia with single-buffer data sources will result in simple recursive-descent parsers.\u00a0\n\u21a9\n\n\n\n\n\n\nSpecifically, if the parser needs to be able to roll back to the very last byte of a buffer, it will keep the entire buffer around.\u00a0\n\u21a9",
            "title": "Resumable Parsers"
        },
        {
            "location": "/guide/04_resumable_parsers/#resumable-parsers",
            "text": "Abulafia parsers have the option 1  of running as coroutines. That is, they are capable of pausing their execution when starved for data, and resume once data is available, all without the need for multithreading and synchronisation.",
            "title": "Resumable Parsers"
        },
        {
            "location": "/guide/04_resumable_parsers/#containersequencecontext",
            "text": "The  Container Sequence Context  is the prefered way of dealing with data chunks. It's fast, flexible, and does as little memory management work as possible at the cost of possibly holding on to chunks of memory longer than absolutely necessary. 2  #include   <vector>  #include   \"abulafia/abulafia.h\"  int   main ()   { \n   auto   pattern   =   * abu :: Uint < 10 , 2 , 2 > ;  \n   std :: vector < unsigned   short >   destination ; \n\n   // Our resumable context will be provided with vectors of char \n   abu :: ContainerSequenceContext < std :: string >   context ; \n\n   auto   parser   =   abu :: make_parser ( pattern ,   context ,   destination ); \n\n   constexpr   int   CHUNK_SIZE   =   256 ; \n   std :: ifstream   file ( \"data.txt\" ); \n\n   abu :: Result   final_result   =   abu :: Result :: PARTIAL ; \n   while ( final_result   ==   abu :: Result :: PARTIAL )   { \n     auto   buffer   =   std :: make_unique < std :: vector < char >> ( CHUNK_SIZE );      \n\n     bool   read_status   =   file . read ( buffer -> data (),   CHUNK_SIZE ); \n\n     buffer -> resize ( file . gcount ()); \n\n     // The context takes ownership of the data, and will let go of it as soon \n     // as it can prove it won't need it again. No memory copies are involved. \n     context . addBuffer ( std :: move ( data ),   read_status   ?   abu :: IsFinal :: NOT_FINAL   :   abu :: IsFinal :: FINAL ); \n\n     final_result   =   parser . consume (); \n   } \n\n   // Deal with the status/destination here... \n\n   return   0 ;  }   The most important takeaway here is that  consume()  can return 3 possible values:     Value  Meaning      abu::Result::SUCCESS  The parser has successfully completed    abu::Result::FAILURE  The parser has failed    abu::Result::PARTIAL  The parser needs more data     Once you have provided a buffer with the  abu::IsFinal::FINAL  flag, the next consume operation will either succeed or fail.      In classic C++ fashion, you only pay for the overhead of this feature if you actually use it. Using abulafia with single-buffer data sources will result in simple recursive-descent parsers.\u00a0 \u21a9    Specifically, if the parser needs to be able to roll back to the very last byte of a buffer, it will keep the entire buffer around.\u00a0 \u21a9",
            "title": "ContainerSequenceContext"
        },
        {
            "location": "/guide/05_actions/",
            "text": "Actions are a means to attach arbitrary pieces of code to patterns. Actions are executed upon successful execution of the attached pattern\n\n\nThe Basics\n\n\nActions are functors that may take an argument and may return a value. They can be attached to parsers using the indexing operator: \n[]\n.\n\n\nExample:\n\n\nauto\n \naction\n \n=\n \n[](){\nstd\n::\ncout\n \n<<\n \n\"pattern has matched!\"\n \n<<\n \nstd\n::\nendl\n;};\n\n\nauto\n \npattern\n \n=\n \n*\nchar_\n()[\naction\n];\n\n\n\n\n\n\nTaking parameters\n\n\nIf the functor takes a parameter, it will behave as the destination of the attached parser.\n1\n\n\nExample:\n```c++\nauto action = \n{std::cout << \"found a letter: \" << c << std::endl;};\nauto pattern = *char_()[action];\n}\n\n\nReturning a value\n\n\nIf the functor returns a value, that value will be assigned to whatever destination is provided to the action.\n\n\nExample:\n```c++\nauto action = \n{return std::toupper(c);};\nauto pattern = *char_()[action];\n}\n\n\n\n\n\n\n\n\n\n\nIn order to do that, Abulafia needs to create a temporary instance of the parameter for the parser to decode into. This means that the type of the parameter has to be default-constructible.\u00a0\n\u21a9",
            "title": "Actions"
        },
        {
            "location": "/guide/05_actions/#the-basics",
            "text": "Actions are functors that may take an argument and may return a value. They can be attached to parsers using the indexing operator:  [] .  Example:  auto   action   =   [](){ std :: cout   <<   \"pattern has matched!\"   <<   std :: endl ;};  auto   pattern   =   * char_ ()[ action ];",
            "title": "The Basics"
        },
        {
            "location": "/guide/05_actions/#taking-parameters",
            "text": "If the functor takes a parameter, it will behave as the destination of the attached parser. 1  Example:\n```c++\nauto action =  {std::cout << \"found a letter: \" << c << std::endl;};\nauto pattern = *char_()[action];\n}",
            "title": "Taking parameters"
        },
        {
            "location": "/guide/05_actions/#returning-a-value",
            "text": "If the functor returns a value, that value will be assigned to whatever destination is provided to the action.  Example:\n```c++\nauto action =  {return std::toupper(c);};\nauto pattern = *char_()[action];\n}      In order to do that, Abulafia needs to create a temporary instance of the parameter for the parser to decode into. This means that the type of the parameter has to be default-constructible.\u00a0 \u21a9",
            "title": "Returning a value"
        },
        {
            "location": "/guide/06_recursivity/",
            "text": "Many grammars need to include themselves. There are many examples of this: Handling simple mathematical expressions, JSON, XML, etc...\n\n\nIn order to handle this, Abulafia provides the \nRecur<>\n1\n pattern. It's by far the most complex stock pattern the library has to offer, but it's extremely versatile.\n\n\nHow Recur Works\n\n\nRecur<>\n works by delaying the definition of the pattern through forward-declaration shenanigans. Using it requires a few steps:\n\n\n\n\nForward declare a struct type, say \nMyRecur\n.\n\n\nDeclare an instance of \nRecur<MyRecur>\n\n\nDefine a pattern, using that instance as if it was fully defined already.\n\n\nDefine MyRecur as struct depending on the type of the resulting pattern.\n\n\nAssign the pattern to the Recur\n instance.\n\n\n\n\nHow to use Recur\n\n\nThis 5 step process is extremely convoluted. Thankfully, abulafia provides the \nABU_Recur_Define()\n macro that gets rid of most of that boilerplate.\n\n\nHere's what it looks like in action:\n\n\nauto\n \ncreate_pattern\n()\n \n{\n\n  \n// steps #1 and #2\n\n  \nabu\n::\nRecur\n<\nstruct\n \nMyRecur\n>\n \nmy_recur\n;\n\n\n  \n// step #3\n\n  \nauto\n \npat\n \n=\n \nint_\n \n|\n \n(\n \n'('\n \n>>\n \nmy_recur\n \n%\n \n','\n \n>>\n \n')'\n);\n\n\n  \n// steps #4 and #5\n\n  \nABU_Recur_Define\n(\nMyRecur\n,\n \nmy_recur\n,\n \npat\n);\n\n\n  \nreturn\n \nmy_recur\n;\n \n// Could also be: return pat;\n\n\n}\n\n\n\n\n\n\nDeclaring a rule pattern.\n\n\n\n\n\n\n\n\n\n\nspirit::qi handles this through the \nRule<>\n parser. Which is a bit of a kitchen sink entry point that was a necessary evil due to the lack of type inference. \nabu::Recur<>\n does only one thing: handle recursion.\u00a0\n\u21a9",
            "title": "Recursivity"
        },
        {
            "location": "/guide/06_recursivity/#how-recur-works",
            "text": "Recur<>  works by delaying the definition of the pattern through forward-declaration shenanigans. Using it requires a few steps:   Forward declare a struct type, say  MyRecur .  Declare an instance of  Recur<MyRecur>  Define a pattern, using that instance as if it was fully defined already.  Define MyRecur as struct depending on the type of the resulting pattern.  Assign the pattern to the Recur  instance.",
            "title": "How Recur Works"
        },
        {
            "location": "/guide/06_recursivity/#how-to-use-recur",
            "text": "This 5 step process is extremely convoluted. Thankfully, abulafia provides the  ABU_Recur_Define()  macro that gets rid of most of that boilerplate.  Here's what it looks like in action:  auto   create_pattern ()   { \n   // steps #1 and #2 \n   abu :: Recur < struct   MyRecur >   my_recur ; \n\n   // step #3 \n   auto   pat   =   int_   |   (   '('   >>   my_recur   %   ','   >>   ')' ); \n\n   // steps #4 and #5 \n   ABU_Recur_Define ( MyRecur ,   my_recur ,   pat ); \n\n   return   my_recur ;   // Could also be: return pat;  }",
            "title": "How to use Recur"
        },
        {
            "location": "/guide/06_recursivity/#declaring-a-rule-pattern",
            "text": "spirit::qi handles this through the  Rule<>  parser. Which is a bit of a kitchen sink entry point that was a necessary evil due to the lack of type inference.  abu::Recur<>  does only one thing: handle recursion.\u00a0 \u21a9",
            "title": "Declaring a rule pattern."
        },
        {
            "location": "/guide/advanced/00_writing_parsers/",
            "text": "Before you proceed\n\n\nBefore you proceed and start writing your own parser types, seriously consider wether you actually need to do this or not. The library of stock parsers provided by Abulafia should allow you to compose whatever it is you actually need.",
            "title": "Writing Parsers"
        },
        {
            "location": "/guide/advanced/00_writing_parsers/#before-you-proceed",
            "text": "Before you proceed and start writing your own parser types, seriously consider wether you actually need to do this or not. The library of stock parsers provided by Abulafia should allow you to compose whatever it is you actually need.",
            "title": "Before you proceed"
        },
        {
            "location": "/reference/",
            "text": "",
            "title": "Quick Reference"
        },
        {
            "location": "/data_sources/single_forward/",
            "text": "",
            "title": "Single Forward"
        },
        {
            "location": "/data_sources/container_sequence/",
            "text": "",
            "title": "Container Sequence"
        },
        {
            "location": "/patterns/leaf/numeric/int/",
            "text": "",
            "title": "Integer"
        },
        {
            "location": "/patterns/leaf/character/",
            "text": "",
            "title": "Character"
        },
        {
            "location": "/patterns/leaf/eoi/",
            "text": "",
            "title": "End-of-input"
        },
        {
            "location": "/patterns/leaf/fail/",
            "text": "",
            "title": "Fail"
        },
        {
            "location": "/patterns/leaf/literal/",
            "text": "",
            "title": "Literal"
        },
        {
            "location": "/patterns/leaf/pass/",
            "text": "",
            "title": "Pass"
        },
        {
            "location": "/patterns/leaf/Symbol/",
            "text": "",
            "title": "Symbol"
        },
        {
            "location": "/patterns/unary/not/",
            "text": "",
            "title": "not"
        },
        {
            "location": "/patterns/unary/repeat/",
            "text": "",
            "title": "repeat"
        },
        {
            "location": "/patterns/binary/except/",
            "text": "",
            "title": "except"
        },
        {
            "location": "/patterns/binary/list/",
            "text": "",
            "title": "list"
        },
        {
            "location": "/patterns/nary/alternative/",
            "text": "",
            "title": "Alternative"
        },
        {
            "location": "/patterns/nary/sequence/",
            "text": "",
            "title": "Sequence"
        },
        {
            "location": "/patterns/recur/",
            "text": "",
            "title": "Recursive"
        },
        {
            "location": "/patterns/action/",
            "text": "",
            "title": "Semantic Action"
        }
    ]
}